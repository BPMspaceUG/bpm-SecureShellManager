#!/usr/bin/env bash
# SM - SSH Manager
# Quick SSH connection manager with zellij session persistence
# Invoke as 'sml' for list mode

# Version: MMDD-HHMM from last git push, or "dev" if not in repo
SM_VERSION="dev"
_sm_dir="$(dirname "${BASH_SOURCE[0]:-$0}")"
if git -C "$_sm_dir" rev-parse --git-dir &>/dev/null; then
    _pushed=$(git -C "$_sm_dir" log -1 --format='%cd' --date=format:'%y%m%d-%H%S' origin/main 2>/dev/null || echo "")
    if [[ -n "$_pushed" ]] && git -C "$_sm_dir" diff --quiet HEAD origin/main 2>/dev/null; then
        SM_VERSION="$_pushed"
    else
        _head=$(git -C "$_sm_dir" log -1 --format='%cd' --date=format:'%y%m%d-%H%S' HEAD 2>/dev/null || echo "dev")
        SM_VERSION="${_head}-draft"
    fi
    unset _pushed _head
fi
unset _sm_dir

set -uo pipefail

CONFIG_DIR="${HOME}/.config/sm"
CONFIG_FILE="${CONFIG_DIR}/connections.conf"
INTERACTIVE_MODE=0

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Escape string for use in regex patterns (grep -E, bash [[ =~ ]])
regex_escape() {
    printf '%s' "$1" | sed 's/[][\\.^$*+?(){}|]/\\&/g'
}

# Set terminal window title (user@hostalias - description)
set_terminal_title() {
    printf '\033]0;%s\007' "$1"
}

# Build a descriptive terminal title from connection info
build_connection_title() {
    local user="$1"
    local host="$2"
    local description="$3"
    local hostalias=$(get_host_alias "$host")
    local display_host="${hostalias:-$host}"
    local title="${user}@${display_host}"
    [[ -n "$description" ]] && title="${title} - ${description}"
    echo "$title"
}

# Reset terminal to sane state (fixes mouse reporting leaks after SSH disconnect)
reset_terminal() {
    # Disable all mouse reporting modes
    printf '\e[?1000l\e[?1002l\e[?1003l\e[?1006l' 2>/dev/null
    # Show cursor
    tput cnorm 2>/dev/null
    # Reset terminal to sane state
    stty sane 2>/dev/null
}

# Zellij mouse configuration
# - Pane selection with mouse requires mouse_mode true (zellij default)
# - Shift+RightClick paste depends on terminal emulator (Windows Terminal: use Ctrl+Shift+V)
# - Ctrl+V paste works via zellij clipboard passthrough
ZELLIJ_MOUSE_FIX=''

# rmate reverse port forwarding (allows editing remote files with local editor)
# Usage on server: rmate filename.txt
RMATE_FORWARD=(-R 52698:localhost:52698)

# SSH timeout for session queries (seconds) - prevents hanging after host reboot
# ConnectTimeout: TCP connect phase. Local timeout wrapper: covers remote command hangs too.
SSH_QUERY_TIMEOUT_OPTS=(-o ConnectTimeout=5 -o ServerAliveInterval=3 -o ServerAliveCountMax=2)
SSH_QUERY_MAX_SECS=10  # hard kill for entire ssh query call

# Initialize config if not exists
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# SM - SSH Manager Configuration
# Format: alias|host|port|user|directory|description|[ssh_key]
#
# Example:
# sm231|contabo2.example.com|22|rob-ico|ico-n8n-prozesse2|N8N Server|
# sm232|contabo2.example.com|22|rob-ico|ico-cert|Cert Service|~/.ssh/special_key
#
# Host aliases (optional):
# hostalias:contabo2.example.com=contabo2
#
# Set default connection:
# default=sm231

EOF
        echo -e "${YELLOW}Config file created: $CONFIG_FILE${NC}"
        echo -e "${YELLOW}Please edit it to add your connections.${NC}"
        exit 0
    fi
}

# Validate port number (1-65535)
validate_port() {
    local port="$1"
    local alias="$2"
    if [[ -z "$port" ]] || [[ ! "$port" =~ ^[0-9]+$ ]] || [[ "$port" -lt 1 ]] || [[ "$port" -gt 65535 ]]; then
        echo -e "${RED}Error: Invalid port '${port}' for connection '${alias}' (must be 1-65535)${NC}" >&2
        return 1
    fi
    return 0
}

# Get default connection
get_default() {
    grep "^default=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2 | tr -d ' ' || echo ""
}

# Get host alias for a hostname
get_host_alias() {
    local hostname="$1"
    local alias_line
    alias_line=$(awk -F'=' -v key="hostalias:${hostname}" '$1 == key {print substr($0, length($1)+2)}' "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$alias_line" ]]; then
        echo "$alias_line"
    else
        echo ""
    fi
}

# List all connections (non-interactive)
list_connections() {
    local default_conn=$(get_default)

    # First pass: calculate column widths
    local w_alias=5 w_host=9 w_user=4 w_dir=9
    while IFS='|' read -r alias host port user directory description key; do
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue
        local ha=$(get_host_alias "$host")
        (( ${#alias} > w_alias )) && w_alias=${#alias}
        (( ${#ha} > w_host )) && w_host=${#ha}
        (( ${#user} > w_user )) && w_user=${#user}
        (( ${#directory} > w_dir )) && w_dir=${#directory}
    done < "$CONFIG_FILE"
    w_alias=$((w_alias + 2))
    w_host=$((w_host + 2))
    w_user=$((w_user + 2))

    local total=$((w_alias + w_host + w_user + w_dir))

    echo -e "${GREEN}=== SM - SSH Manager ${SM_VERSION} ===${NC}"
    printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY"
    printf '%*s\n' "$total" '' | tr ' ' '-'

    while IFS='|' read -r alias host port user directory description key; do
        # Skip comments, empty lines, host aliases, default
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        local hostalias=$(get_host_alias "$host")

        # Highlight default (green row)
        if [[ "$alias" == "$default_conn" ]]; then
            printf "${GREEN}%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s${NC}\n" "$alias" "$hostalias" "$user" "$directory"
        else
            printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s\n" "$alias" "$hostalias" "$user" "$directory"
        fi
    done < "$CONFIG_FILE"
}

# Interactive selection with arrow keys
interactive_select() {
    INTERACTIVE_MODE=1
    local default_conn=$(get_default)
    local aliases=()
    local hostaliases=()
    local users=()
    local directories=()

    # Build arrays
    while IFS='|' read -r alias host port user directory description key; do
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        aliases+=("$alias")
        hostaliases+=("$(get_host_alias "$host")")
        users+=("$user")
        directories+=("$directory")
    done < "$CONFIG_FILE"

    local count=${#aliases[@]}
    if [[ $count -eq 0 ]]; then
        echo -e "${RED}No connections configured${NC}"
        exit 1
    fi

    # Calculate dynamic column widths
    local w_alias=5 w_host=9 w_user=4 w_dir=9
    for i in "${!aliases[@]}"; do
        (( ${#aliases[$i]} > w_alias )) && w_alias=${#aliases[$i]}
        (( ${#hostaliases[$i]} > w_host )) && w_host=${#hostaliases[$i]}
        (( ${#users[$i]} > w_user )) && w_user=${#users[$i]}
        (( ${#directories[$i]} > w_dir )) && w_dir=${#directories[$i]}
    done
    w_alias=$((w_alias + 2))
    w_host=$((w_host + 2))
    w_user=$((w_user + 2))
    local total=$((w_alias + w_host + w_user + w_dir + 2))

    # Find initial selection (default or first)
    local selected=0
    for i in "${!aliases[@]}"; do
        if [[ "${aliases[$i]}" == "$default_conn" ]]; then
            selected=$i
            break
        fi
    done

    # Hide cursor and setup cleanup
    cleanup() {
        INTERACTIVE_MODE=0
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Set static window title for menu
    set_terminal_title "Secure Shell Manager"

    # Draw function
    draw_menu() {
        # Move to top and clear
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== SM - SSH Manager ${SM_VERSION} ===${NC}"
        printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY"
        printf '%*s\n' "$total" '' | tr ' ' '-'

        local wa=$((w_alias - 2))
        for i in "${!aliases[@]}"; do
            local is_default=false
            [[ "${aliases[$i]}" == "$default_conn" ]] && is_default=true

            if [[ $i -eq $selected ]]; then
                # Selected row - inverse video
                if [[ "$is_default" == "true" ]]; then
                    printf "${GREEN}\e[7m> %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s\e[27m${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                else
                    printf "\e[7m> %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s\e[27m\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                fi
            else
                if [[ "$is_default" == "true" ]]; then
                    printf "${GREEN}  %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                else
                    printf "  %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                fi
            fi
        done

        echo ""
        echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | A: Auth | P: Parallel | L: List | H: Hard Reset | D: Default | Q: Exit${NC}"
    }

    redraw_menu() {
        tput civis
        tput cup 0 0
        tput ed
        draw_menu
    }

    # Draw menu
    redraw_menu

    # Read keys
    while true; do
        # Read single key
        IFS= read -rsn1 key || continue

        if [[ "$key" == $'\x1b' ]]; then
            # Escape sequence - read more
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow - wrap to bottom
                if [[ $selected -gt 0 ]]; then
                    selected=$((selected - 1))
                else
                    selected=$((count - 1))
                fi
                draw_menu
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow - wrap to top
                if [[ $selected -lt $((count - 1)) ]]; then
                    selected=$((selected + 1))
                else
                    selected=0
                fi
                draw_menu
            elif [[ -z "$seq" ]]; then
                # Just Escape
                tput cnorm
                exit 0
            fi
        elif [[ "$key" == '' ]]; then
            # Enter key - connect with zellij session restore
            tput cnorm
            connect "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'a' || "$key" == 'A' ]]; then
            # A key - Auth mode with port forwarding (1455)
            tput cnorm
            connect_auth "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'p' || "$key" == 'P' ]]; then
            # P key - create new parallel session
            tput cnorm
            connect_parallel "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'h' || "$key" == 'H' ]]; then
            # H key - hard reset (always delete and create fresh, no questions)
            tput cnorm
            connect_hard_reset "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'l' || "$key" == 'L' ]]; then
            # L key - list sessions on server and connect
            tput cnorm
            list_and_connect "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'd' || "$key" == 'D' ]]; then
            # D key - set default
            set_default "${aliases[$selected]}"
            default_conn="${aliases[$selected]}"
            draw_menu
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q to quit
            tput cnorm
            exit 0
        fi
    done
}

# Set default connection
set_default() {
    local new_default="$1"

    # Check if connection exists
    if ! awk -F'|' -v key="$new_default" '$1 == key {found=1; exit} END {exit !found}' "$CONFIG_FILE"; then
        echo -e "${RED}Error: Connection '$new_default' not found${NC}"
        exit 1
    fi

    # Remove old default
    sed -i '/^default=/d' "$CONFIG_FILE"

    # Add new default
    echo "default=$new_default" >> "$CONFIG_FILE"

    echo -e "${GREEN}Default set to: $new_default${NC}"
}

# === Session Helper Functions ===

# Get all sessions for an alias (supports parallel sessions like alias, alias_2, alias_3)
# Runs locally - queries remote server via SSH
get_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local safe_alias
    safe_alias=$(regex_escape "$alias")
    # Build timeout command array
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    # Get sessions from remote, strip ANSI codes, filter by alias pattern
    timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | \
        sed 's/\x1b\[[0-9;]*m//g' | \
        grep -E "^${safe_alias}(_[0-9]+)?(\s|$)" | \
        awk '{print $1}'
}

# Count sessions for an alias
count_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    get_sessions_for_alias "$alias" "${ssh_cmd[@]}" | wc -l
}

# Get next parallel session name
get_next_session_name() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")
    local count
    count=$(echo "$sessions" | grep -c . || echo "0")

    if [[ $count -eq 0 ]]; then
        echo "$alias"
    else
        # Find highest number suffix and increment
        local max=1
        while IFS= read -r s; do
            if [[ "$s" =~ _([0-9]+)$ ]]; then
                local n="${BASH_REMATCH[1]}"
                (( n >= max )) && max=$((n + 1))
            fi
        done <<< "$sessions"
        echo "${alias}_${max}"
    fi
}

# Check if a specific session is exited/dead
is_session_exited() {
    local session="$1"
    shift
    local ssh_cmd=("$@")
    local safe_session
    safe_session=$(regex_escape "$session")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | grep -Eq "^${safe_session}.*EXITED"
}

# Cleanup dead/exited sessions for an alias
cleanup_dead_sessions() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local safe_alias
    safe_alias=$(regex_escape "$alias")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local sessions
    sessions=$(timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g')

    while IFS= read -r line; do
        if [[ "$line" =~ ^(${safe_alias}(_[0-9]+)?).*EXITED ]]; then
            local dead_session="${BASH_REMATCH[1]}"
            timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij delete-session ${dead_session} --force 2>/dev/null" 2>/dev/null || true
        fi
    done <<< "$sessions"
}

# Delete all sessions for an alias
delete_all_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    while IFS= read -r session; do
        [[ -n "$session" ]] && "${ssh_cmd_timeout[@]}" "zellij delete-session ${session} --force 2>/dev/null" 2>/dev/null || true
    done <<< "$sessions"
}

# === End Session Helper Functions ===

# List sessions on server and connect to selected one
list_and_connect() {
    local alias="$1"
    local auth_mode="${2:-}"  # Optional: "auth" for port forwarding mode
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection (awk for exact field match — no regex injection)
    local line
    line=$(awk -F'|' -v key="$alias" '$1 == key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    # Build SSH command array (base without auth port)
    local ssh_cmd=(ssh)
    [[ -n "$key" ]] && ssh_cmd+=(-i "$key")
    ssh_cmd+=("${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")

    # Build SSH command array with auth port if needed
    local ssh_cmd_auth=(ssh)
    [[ -n "$key" ]] && ssh_cmd_auth+=(-i "$key")
    ssh_cmd_auth+=(-L 1455:localhost:1455 "${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")

    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd \"${directory}\" 2>/dev/null; "

    echo -e "${GREEN}=== Sessions on $alias ($description) ===${NC}"
    echo -e "${YELLOW}Fetching sessions...${NC}"

    # Get sessions from server (strip ANSI color codes) - filter by alias pattern
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    if [[ -z "$sessions" ]]; then
        echo -e "${RED}No sessions found for '$alias'.${NC}"
        read -p "Create new session '$alias'? [Y/n/b=back] " confirm
        if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        elif [[ "$confirm" == "b" || "$confirm" == "B" ]]; then
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        fi
        local final_ssh=("${ssh_cmd[@]}")
        [[ "$auth_mode" == "auth" ]] && final_ssh=("${ssh_cmd_auth[@]}")
        set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
        "${final_ssh[@]}" -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${alias}"
        reset_terminal
        if [[ $stay_interactive -eq 1 ]]; then
            return 0
        else
            exit 0
        fi
    fi

    # Build session array from filtered sessions
    local session_array=()
    while IFS= read -r session; do
        [[ -n "$session" ]] && session_array+=("$session")
    done <<< "$sessions"

    # Add "New parallel session" option
    session_array+=("[NEW] Create parallel session")

    local count=${#session_array[@]}
    local selected=0

    # Hide cursor and setup cleanup
    cleanup() {
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Cache session status once (avoid SSH call per session per redraw)
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local _cached_session_list=""
    refresh_session_cache() {
        _cached_session_list=$(timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' || echo "")
    }
    refresh_session_cache

    # Draw function
    draw_sessions() {
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== Sessions for $alias ($description) ===${NC}"
        if [[ "$auth_mode" == "auth" ]]; then
            echo -e "${YELLOW}[Auth Mode: Port 1455 forwarding enabled]${NC}"
        fi
        echo ""

        for i in "${!session_array[@]}"; do
            local session="${session_array[$i]}"
            local is_new=false
            local is_exited=false
            [[ "$session" == "[NEW]"* ]] && is_new=true
            # Check cached session list for exited status
            local safe_session
            safe_session=$(regex_escape "$session")
            echo "$_cached_session_list" | grep -Eq "^${safe_session}.*EXITED" && is_exited=true

            if [[ $i -eq $selected ]]; then
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}\e[7m> %s\e[27m${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}\e[7m> %s (EXITED)\e[27m${NC}\n" "$session"
                else
                    printf "${GREEN}\e[7m> %s\e[27m${NC}\n" "$session"
                fi
            else
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}  %s${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}  %s (EXITED)${NC}\n" "$session"
                else
                    printf "${GREEN}  %s${NC}\n" "$session"
                fi
            fi
        done

        echo ""
        echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | H: Hard Reset | Q: Back${NC}"
    }

    tput cup 0 0
    tput ed
    draw_sessions

    # Read keys
    while true; do
        IFS= read -rsn1 key || continue

        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow
                if [[ $selected -gt 0 ]]; then
                    selected=$((selected - 1))
                else
                    selected=$((count - 1))
                fi
                draw_sessions
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow
                if [[ $selected -lt $((count - 1)) ]]; then
                    selected=$((selected + 1))
                else
                    selected=0
                fi
                draw_sessions
            elif [[ -z "$seq" ]]; then
                # Escape - back
                tput cnorm
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            fi
        elif [[ "$key" == '' ]]; then
            # Enter - connect to selected or create new parallel
            tput cnorm
            local selected_session="${session_array[$selected]}"

            if [[ "$selected_session" == "[NEW]"* ]]; then
                echo -e "${GREEN}Creating new parallel session...${NC}"
                connect_parallel "$alias" "$auth_mode"
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            else
                local session_name="$selected_session"
                echo -e "${GREEN}Connecting to session '$session_name'...${NC}"
                local final_ssh=("${ssh_cmd[@]}")
                [[ "$auth_mode" == "auth" ]] && final_ssh=("${ssh_cmd_auth[@]}")
                set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
                "${final_ssh[@]}" -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach ${session_name}"
                reset_terminal
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            fi
        elif [[ "$key" == 'h' || "$key" == 'H' ]]; then
            # H - hard reset selected session only
            local selected_session="${session_array[$selected]}"
            if [[ "$selected_session" == "[NEW]"* ]]; then
                # Can't reset [NEW] option, just create parallel
                tput cnorm
                echo -e "${GREEN}Creating new parallel session...${NC}"
                connect_parallel "$alias" "$auth_mode"
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            else
                tput cnorm
                echo -e "${YELLOW}Hard reset session '$selected_session'...${NC}"
                connect_hard_reset "$alias" "$selected_session"
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            fi
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q - back to main menu
            tput cnorm
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        fi
    done
}

# Hard reset - delete session(s) and create fresh
# If >1 sessions exist, asks user if ALL should be reset
connect_hard_reset() {
    local alias="$1"
    local specific_session="${2:-}"  # Optional: reset only this specific session (for submenu H)
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection (awk for exact field match — no regex injection)
    local line
    line=$(awk -F'|' -v key="$alias" '$1 == key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    # Build SSH command array
    local ssh_cmd=(ssh)
    [[ -n "$key" ]] && ssh_cmd+=(-i "$key")
    ssh_cmd+=("${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")

    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd \"${directory}\" 2>/dev/null; "

    # If specific session provided (from submenu H), reset only that one
    if [[ -n "$specific_session" ]]; then
        echo -e "${GREEN}Hard Reset: $specific_session${NC}"
        echo -e "${YELLOW}Deleting session '${specific_session}' and creating fresh...${NC}"
        echo ""
        local remote_cmd="zellij delete-session ${specific_session} --force 2>/dev/null; ${cd_cmd}zellij attach -c ${specific_session}"
        set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
        "${ssh_cmd[@]}" -t "$remote_cmd"
        reset_terminal
        if [[ $stay_interactive -eq 1 ]]; then
            return 0
        else
            exit 0
        fi
    fi

    # Skip session query — just force-delete and create fresh
    # This ensures Hard Reset works even when the server is slow or sessions are stale
    echo -e "${GREEN}Hard Reset: $alias ($description)${NC}"
    echo -e "${YELLOW}Deleting session '${alias}' and creating fresh...${NC}"
    echo ""

    # Force-delete primary session and any parallel sessions, then create fresh
    local safe_alias_remote
    safe_alias_remote=$(regex_escape "$alias")
    local remote_cmd="for s in \$(zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -oE '^${safe_alias_remote}(_[0-9]+)?' || true); do zellij delete-session \"\$s\" --force 2>/dev/null; done; ${cd_cmd}zellij attach -c ${alias}"
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
    "${ssh_cmd[@]}" -t "$remote_cmd"
    reset_terminal
    if [[ $stay_interactive -eq 1 ]]; then
        return 0
    else
        exit 0
    fi
}

# Connect to a connection (smart routing based on session count)
connect() {
    local alias="$1"
    local auth_mode="${2:-}"  # Optional: "auth" for port forwarding mode
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection (awk for exact field match — no regex injection)
    local line
    line=$(awk -F'|' -v key="$alias" '$1 == key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    # Build SSH command array (without -t for session queries)
    local ssh_cmd=(ssh)
    [[ -n "$key" ]] && ssh_cmd+=(-i "$key")
    ssh_cmd+=("${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")

    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd \"${directory}\" 2>/dev/null; "

    # Cleanup dead sessions first
    echo -e "${YELLOW}Checking sessions...${NC}"
    cleanup_dead_sessions "$alias" "${ssh_cmd[@]}"

    # Count remaining sessions
    local session_count
    session_count=$(count_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    if [[ $session_count -gt 1 ]]; then
        # Multiple sessions exist -> go to session submenu
        echo -e "${BLUE}Found $session_count sessions for $alias${NC}"
        list_and_connect "$alias" "$auth_mode"
        return $?
    fi

    # Get existing session or use primary name
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")
    local session_name
    if [[ $session_count -eq 1 ]]; then
        session_name=$(echo "$sessions" | head -1)
    else
        session_name="$alias"
    fi

    # Build final SSH command array with auth port forwarding if needed
    local final_ssh_cmd=("${ssh_cmd[@]}")
    if [[ "$auth_mode" == "auth" ]]; then
        # Rebuild with auth port forwarding
        final_ssh_cmd=(ssh)
        [[ -n "$key" ]] && final_ssh_cmd+=(-i "$key")
        final_ssh_cmd+=(-L 1455:localhost:1455 "${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")
    fi

    # Build remote command
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Connecting to: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"
    if [[ "$auth_mode" == "auth" ]]; then
        echo -e "${YELLOW}Port Forward: localhost:1455 -> remote:1455${NC}"
    fi
    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi
    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Set terminal window title to user@host - description
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"

    # Execute SSH and reset terminal after disconnect
    run_ssh "$remote_cmd" "$user" "$host" "$port" "${final_ssh_cmd[@]}"
    reset_terminal
}

# Connect with port forwarding for authentication (port 1455)
# Delegates to connect() with auth mode flag
connect_auth() {
    local alias="$1"
    connect "$alias" "auth"
}

# Create a new parallel session (e.g., alias_2, alias_3, ...)
connect_parallel() {
    local alias="$1"
    local auth_mode="${2:-}"
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection (awk for exact field match — no regex injection)
    local line
    line=$(awk -F'|' -v key="$alias" '$1 == key' "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    # Build SSH command array
    local ssh_cmd=(ssh)
    [[ -n "$key" ]] && ssh_cmd+=(-i "$key")
    [[ "$auth_mode" == "auth" ]] && ssh_cmd+=(-L 1455:localhost:1455)
    ssh_cmd+=("${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")

    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd \"${directory}\" 2>/dev/null; "

    # Get next available parallel session name
    echo -e "${YELLOW}Finding next available session name...${NC}"
    local session_name
    session_name=$(get_next_session_name "$alias" "${ssh_cmd[@]}")

    # Build remote command
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Creating parallel session: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"
    if [[ "$auth_mode" == "auth" ]]; then
        echo -e "${YELLOW}Port Forward: localhost:1455 -> remote:1455${NC}"
    fi
    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi
    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Set terminal window title to user@host - description
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"

    # Execute SSH
    run_ssh "$remote_cmd" "$user" "$host" "$port" "${ssh_cmd[@]}"
    reset_terminal
}

# Run SSH with detailed error handling
# Args: remote_cmd, user, host, port, ssh_cmd_elements...
run_ssh() {
    local remote_cmd="$1"
    local user="$2"
    local host="$3"
    local port="$4"
    shift 4
    local ssh_cmd=("$@")

    # Run SSH and capture exit code + stderr (using temp file for reliable capture)
    local stderr_file=$(mktemp)
    trap "rm -f '$stderr_file'" RETURN

    set +e
    "${ssh_cmd[@]}" -t "$remote_cmd" 2>"$stderr_file"
    local exit_code=$?
    set -e

    local ssh_stderr=$(cat "$stderr_file" 2>/dev/null || echo "")

    # Handle common SSH errors
    if [[ $exit_code -ne 0 ]]; then
        # Reset terminal first (fixes mouse tracking leaks from broken connections)
        reset_terminal

        # Check for broken pipe (mid-session disconnect) - exit cleanly
        if [[ "$ssh_stderr" == *"Broken pipe"* ]] || [[ "$ssh_stderr" == *"client_loop"* ]]; then
            echo ""
            echo -e "${YELLOW}Connection closed (broken pipe)${NC}"
            return 0
        fi

        echo ""
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${RED}SSH Connection Failed (Exit code: $exit_code)${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        case $exit_code in
            1)
                echo -e "${YELLOW}Generic error. Possible causes:${NC}"
                echo "  • Wrong hostname or IP address"
                echo "  • Network unreachable"
                echo "  • SSH key passphrase incorrect"
                ;;
            2)
                echo -e "${YELLOW}SSH client error. Possible causes:${NC}"
                echo "  • Invalid SSH options"
                echo "  • Configuration file syntax error"
                ;;
            255)
                echo -e "${YELLOW}Connection refused or failed. Possible causes:${NC}"
                echo ""
                echo -e "${BLUE}Server-side (sshd) issues:${NC}"
                echo "  • sshd not running: sudo systemctl start sshd"
                echo "  • sshd not enabled: sudo systemctl enable sshd"
                echo "  • Wrong port: check /etc/ssh/sshd_config 'Port' setting"
                echo "  • Firewall blocking: sudo ufw allow ${port}/tcp"
                echo ""
                echo -e "${BLUE}Authentication issues:${NC}"
                echo "  • User '${user}' doesn't exist on server"
                echo "  • SSH key not in ~/.ssh/authorized_keys"
                echo "  • PasswordAuthentication disabled in sshd_config"
                echo "  • PubkeyAuthentication disabled in sshd_config"
                echo ""
                echo -e "${BLUE}Port forwarding issues (if using -L):${NC}"
                echo "  • AllowTcpForwarding must be 'yes' in sshd_config"
                echo "  • GatewayPorts may need to be 'yes'"
                echo "  • Port 1455 already in use locally: lsof -i :1455"
                echo ""
                echo -e "${BLUE}To check sshd config on server:${NC}"
                echo "  sudo sshd -T | grep -E '(port|allowtcp|pubkey|password)'"
                ;;
            *)
                echo -e "${YELLOW}Unknown error. Check:${NC}"
                echo "  • Network connectivity: ping ${host}"
                echo "  • SSH service: ssh -v ${user}@${host}"
                ;;
        esac

        echo ""
        echo -e "${BLUE}Debug with: ssh -vvv -p ${port} ${user}@${host}${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        read -p "Press Enter to continue..."
    fi
}

# Main
main() {
    init_config

    # Get script name (for smd, sml detection)
    local script_name=$(basename "$0")

    # Handle different invocations
    case "$script_name" in
        smd)
            # smd = connect to default (quick access)
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sml)
            # sml = list zellij sessions on default server
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                list_and_connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sm)
            # sm with arguments
            if [[ $# -eq 0 ]]; then
                # No args = interactive selection
                interactive_select
            elif [[ "$1" == "list" ]]; then
                list_connections
            elif [[ "$1" == "set" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm set <alias>${NC}"
                    exit 1
                fi
                set_default "$2"
            else
                # Direct connection by alias
                connect "$1"
            fi
            ;;
        *)
            echo -e "${RED}Unknown command: $script_name${NC}"
            exit 1
            ;;
    esac
}

main "$@"
