#!/usr/bin/env bash
# SM - SSH Manager
# Quick SSH connection manager with zellij session persistence
# Invoke as 'sml' for list mode

# Version: MMDD-HHMM from last git push, or "dev" if not in repo
SM_VERSION="dev"
_sm_dir="$(dirname "${BASH_SOURCE[0]:-$0}")"
if git -C "$_sm_dir" rev-parse --git-dir &>/dev/null; then
    _pushed=$(git -C "$_sm_dir" log -1 --format='%cd' --date=format:'%y%m%d-%H%S' origin/main 2>/dev/null || echo "")
    if [[ -n "$_pushed" ]] && git -C "$_sm_dir" diff --quiet HEAD origin/main 2>/dev/null; then
        SM_VERSION="$_pushed"
    else
        _head=$(git -C "$_sm_dir" log -1 --format='%cd' --date=format:'%y%m%d-%H%S' HEAD 2>/dev/null || echo "dev")
        SM_VERSION="${_head}-draft"
    fi
    unset _pushed _head
fi
unset _sm_dir

set -uo pipefail

CONFIG_DIR="${HOME}/.config/sm"
CONFIG_FILE="${CONFIG_DIR}/connections.conf"
INTERACTIVE_MODE=0

# Colors (may be cleared by --no-color or NO_COLOR env var)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Disable colors if NO_COLOR env var is set (https://no-color.org/)
if [[ -n "${NO_COLOR:-}" ]]; then
    RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

# Timeout wrapper: falls back to running command directly if timeout is unavailable
HAS_TIMEOUT=true
if ! command -v timeout &>/dev/null; then
    HAS_TIMEOUT=false
fi
_timeout() {
    if [[ "$HAS_TIMEOUT" == "true" ]]; then
        timeout "$@"
    else
        # Skip the timeout duration arg, run command directly
        shift
        "$@"
    fi
}

# Show usage information
show_help() {
    cat <<'HELPEOF'
SM - SSH Manager
Quick SSH connection manager with zellij session persistence.

Usage:
  sm                          Interactive connection selector
  sm <alias>                  Connect to alias directly
  sm list                     List all connections
  sm set <alias>              Set default connection
  sm edit                     Open config in $EDITOR
  sm test <alias>             Test SSH connectivity
  sm validate                 Validate config file
  sm add                      Add a new connection (wizard)
  sm remove <alias>           Remove a connection
  sm auth <alias>             Connect with auth port forwarding (1455)
  sm parallel <alias>         Create a new parallel session
  sm reset <alias> [--force]  Hard reset sessions for alias
  sm sessions <alias>         List and select sessions on server
  sm completions [bash|zsh]   Output shell completion script
  sm --help, -h               Show this help
  sm --version, -v            Show version

Shortcuts:
  smd                         Connect to default connection
  sml                         List sessions on default server

Config: ~/.config/sm/connections.conf
Format: alias|host|port|user|directory|description|[ssh_key]

Options:
  --no-color                  Disable colored output
HELPEOF
}

# Escape string for use in regex patterns (grep -E, bash [[ =~ ]])
regex_escape() {
    printf '%s' "$1" | sed 's/[][\\.^$*+?(){}|]/\\&/g'
}

# Set terminal window title (user@hostalias - description)
# Strips control characters to prevent terminal escape injection
set_terminal_title() {
    local sanitized
    sanitized=$(printf '%s' "$1" | tr -d '\000-\037\177')
    printf '\033]0;%s\007' "$sanitized"
}

# Build a descriptive terminal title from connection info
build_connection_title() {
    local user="$1"
    local host="$2"
    local description="$3"
    local hostalias=$(get_host_alias "$host")
    local display_host="${hostalias:-$host}"
    local title="${user}@${display_host}"
    [[ -n "$description" ]] && title="${title} - ${description}"
    echo "$title"
}

# Reset terminal to sane state (fixes mouse reporting leaks after SSH disconnect)
reset_terminal() {
    # Disable all mouse reporting modes
    printf '\e[?1000l\e[?1002l\e[?1003l\e[?1006l' 2>/dev/null
    # Show cursor
    tput cnorm 2>/dev/null
    # Reset terminal to sane state
    stty sane 2>/dev/null
}

# === DRY Helper Functions ===

# Parse connection config by alias, sets CONN_* globals
parse_connection() {
    local alias="$1"
    CONN_HOST="" CONN_PORT="" CONN_USER="" CONN_DIR="" CONN_DESC="" CONN_KEY=""
    local line
    line=$(awk -F'|' -v key="$alias" '$1 == key' "$CONFIG_FILE" 2>/dev/null || echo "")
    [[ -z "$line" ]] && return 1
    IFS='|' read -r _ CONN_HOST CONN_PORT CONN_USER CONN_DIR CONN_DESC CONN_KEY <<< "$line"
    return 0
}

# Exit or return based on interactive mode
exit_or_return() {
    local code="${1:-0}"
    local stay="${2:-0}"
    if [[ $stay -eq 1 ]]; then
        return "$code"
    else
        exit "$code"
    fi
}

# Build SSH command array, sets global SSH_CMD
build_ssh_cmd() {
    local host="$1" port="$2" user="$3" key="$4" auth_mode="${5:-}"
    SSH_CMD=()
    SSH_CMD=(ssh)
    [[ -n "$key" ]] && SSH_CMD+=(-i "$key")
    [[ "$auth_mode" == "auth" ]] && SSH_CMD+=(-L 1455:localhost:1455)
    SSH_CMD+=("${RMATE_FORWARD[@]}" -p "$port" "${user}@${host}")
}

# Build cd command string for remote execution
build_cd_cmd() {
    local directory="$1"
    [[ -n "$directory" ]] && echo "cd \"${directory}\" 2>/dev/null; " || echo ""
}

# Calculate column widths for connection display, sets W_* globals
calculate_column_widths() {
    W_ALIAS=5; W_HOST=9; W_USER=4; W_DIR=9; W_DESC=11
    while IFS='|' read -r alias host port user directory description key; do
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue
        local ha=$(get_host_alias "$host")
        (( ${#alias} > W_ALIAS )) && W_ALIAS=${#alias}
        (( ${#ha} > W_HOST )) && W_HOST=${#ha}
        (( ${#user} > W_USER )) && W_USER=${#user}
        (( ${#directory} > W_DIR )) && W_DIR=${#directory}
        (( ${#description} > W_DESC )) && W_DESC=${#description}
    done < "$CONFIG_FILE"
    W_ALIAS=$((W_ALIAS + 2))
    W_HOST=$((W_HOST + 2))
    W_USER=$((W_USER + 2))
    W_DESC=$((W_DESC + 2))
}

# === End DRY Helper Functions ===

# Zellij mouse configuration
# - Pane selection with mouse requires mouse_mode true (zellij default)
# - Shift+RightClick paste depends on terminal emulator (Windows Terminal: use Ctrl+Shift+V)
# - Ctrl+V paste works via zellij clipboard passthrough
ZELLIJ_MOUSE_FIX=''

# rmate reverse port forwarding (allows editing remote files with local editor)
# Usage on server: rmate filename.txt
RMATE_FORWARD=(-R 52698:localhost:52698)

# SSH timeout for session queries (seconds) - prevents hanging after host reboot
# ConnectTimeout: TCP connect phase. Local timeout wrapper: covers remote command hangs too.
SSH_QUERY_TIMEOUT_OPTS=(-o ConnectTimeout=5 -o ServerAliveInterval=3 -o ServerAliveCountMax=2)
SSH_QUERY_MAX_SECS=10  # hard kill for entire ssh query call

# Initialize config if not exists
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# SM - SSH Manager Configuration
# Format: alias|host|port|user|directory|description|[ssh_key]
#
# Example:
# sm231|contabo2.example.com|22|rob-ico|ico-n8n-prozesse2|N8N Server|
# sm232|contabo2.example.com|22|rob-ico|ico-cert|Cert Service|~/.ssh/special_key
#
# Host aliases (optional):
# hostalias:contabo2.example.com=contabo2
#
# Set default connection:
# default=sm231

EOF
        echo -e "${YELLOW}Config file created: $CONFIG_FILE${NC}"
        echo -e "${YELLOW}Please edit it to add your connections.${NC}"
        exit 0
    fi
}

# Validate port number (1-65535)
validate_port() {
    local port="$1"
    local alias="$2"
    if [[ -z "$port" ]] || [[ ! "$port" =~ ^[0-9]+$ ]] || [[ "$port" -lt 1 ]] || [[ "$port" -gt 65535 ]]; then
        echo -e "${RED}Error: Invalid port '${port}' for connection '${alias}' (must be 1-65535)${NC}" >&2
        return 1
    fi
    return 0
}

# Get default connection
get_default() {
    grep "^default=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2 | tr -d ' ' || echo ""
}

# Get host alias for a hostname
get_host_alias() {
    local hostname="$1"
    local alias_line
    alias_line=$(awk -F'=' -v key="hostalias:${hostname}" '$1 == key {print substr($0, length($1)+2)}' "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$alias_line" ]]; then
        echo "$alias_line"
    else
        echo ""
    fi
}

# List all connections (non-interactive)
list_connections() {
    local default_conn=$(get_default)

    # First pass: calculate column widths
    calculate_column_widths
    local w_alias=$W_ALIAS w_host=$W_HOST w_user=$W_USER w_dir=$W_DIR w_desc=$W_DESC

    local total=$((w_alias + w_host + w_user + w_dir + w_desc))

    echo -e "${GREEN}=== SM - SSH Manager ${SM_VERSION} ===${NC}"
    printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY" "DESCRIPTION"
    printf '%*s\n' "$total" '' | tr ' ' '-'

    while IFS= read -r raw_line; do
        # Show group headers
        if [[ "$raw_line" =~ ^#\ group:\ (.+)$ ]]; then
            echo ""
            echo -e "${BLUE}--- ${BASH_REMATCH[1]} ---${NC}"
            continue
        fi

        IFS='|' read -r alias host port user directory description key <<< "$raw_line"

        # Skip comments, empty lines, host aliases, default
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        local hostalias=$(get_host_alias "$host")

        # Highlight default (green row)
        if [[ "$alias" == "$default_conn" ]]; then
            printf "${GREEN}%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s${NC}\n" "$alias" "$hostalias" "$user" "$directory" "$description"
        else
            printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\n" "$alias" "$hostalias" "$user" "$directory" "$description"
        fi
    done < "$CONFIG_FILE"
}

# Interactive selection with arrow keys
interactive_select() {
    INTERACTIVE_MODE=1
    local default_conn=$(get_default)
    local aliases=()
    local hostaliases=()
    local users=()
    local directories=()
    local descriptions=()
    local groups=()
    local current_group=""

    # Build arrays
    while IFS= read -r raw_line; do
        if [[ "$raw_line" =~ ^#\ group:\ (.+)$ ]]; then
            current_group="${BASH_REMATCH[1]}"
            continue
        fi

        IFS='|' read -r alias host port user directory description key <<< "$raw_line"

        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        aliases+=("$alias")
        hostaliases+=("$(get_host_alias "$host")")
        users+=("$user")
        directories+=("$directory")
        descriptions+=("$description")
        groups+=("$current_group")
    done < "$CONFIG_FILE"

    local count=${#aliases[@]}
    if [[ $count -eq 0 ]]; then
        echo -e "${RED}No connections configured${NC}"
        exit 1
    fi

    # Calculate dynamic column widths
    calculate_column_widths
    local w_alias=$W_ALIAS w_host=$W_HOST w_user=$W_USER w_dir=$W_DIR w_desc=$W_DESC
    local total=$((w_alias + w_host + w_user + w_dir + w_desc + 2))

    # Find initial selection (default or first)
    local selected=0
    for i in "${!aliases[@]}"; do
        if [[ "${aliases[$i]}" == "$default_conn" ]]; then
            selected=$i
            break
        fi
    done

    # Hide cursor and setup cleanup
    cleanup() {
        INTERACTIVE_MODE=0
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Set static window title for menu
    set_terminal_title "Secure Shell Manager"

    # Search/filter state
    local search_mode=false
    local filter_text=""
    local filtered_indices=()

    # Rebuild filtered_indices from filter_text
    rebuild_filter() {
        filtered_indices=()
        if [[ -z "$filter_text" ]]; then
            for i in "${!aliases[@]}"; do
                filtered_indices+=("$i")
            done
        else
            local lc_filter
            lc_filter=$(printf '%s' "$filter_text" | tr '[:upper:]' '[:lower:]')
            for i in "${!aliases[@]}"; do
                local haystack
                haystack=$(printf '%s %s %s %s %s' "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}" "${descriptions[$i]}" | tr '[:upper:]' '[:lower:]')
                if [[ "$haystack" == *"$lc_filter"* ]]; then
                    filtered_indices+=("$i")
                fi
            done
        fi
    }
    # Initialize with all entries
    rebuild_filter

    # Draw function
    draw_menu() {
        # Move to top and clear
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== SM - SSH Manager ${SM_VERSION} ===${NC}"
        if [[ "$search_mode" == "true" || -n "$filter_text" ]]; then
            echo -e "${BLUE}Filter: ${filter_text}_${NC}"
        fi
        printf "%-${w_alias}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY" "DESCRIPTION"
        printf '%*s\n' "$total" '' | tr ' ' '-'

        local wa=$((w_alias - 2))
        local fi_count=${#filtered_indices[@]}

        if [[ $fi_count -eq 0 ]]; then
            echo -e "${YELLOW}  No matches${NC}"
        else
            local last_group=""
            for fi_pos in "${!filtered_indices[@]}"; do
                local i="${filtered_indices[$fi_pos]}"
                # Show group header if group changed and not in filter mode
                if [[ -z "$filter_text" && -n "${groups[$i]}" && "${groups[$i]}" != "$last_group" ]]; then
                    echo -e "${BLUE}  --- ${groups[$i]} ---${NC}"
                    last_group="${groups[$i]}"
                fi
                local is_default=false
                [[ "${aliases[$i]}" == "$default_conn" ]] && is_default=true

                if [[ $fi_pos -eq $selected ]]; then
                    # Selected row - inverse video
                    if [[ "$is_default" == "true" ]]; then
                        printf "${GREEN}\e[7m> %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\e[27m${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}" "${descriptions[$i]}"
                    else
                        printf "\e[7m> %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\e[27m\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}" "${descriptions[$i]}"
                    fi
                else
                    if [[ "$is_default" == "true" ]]; then
                        printf "${GREEN}  %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}" "${descriptions[$i]}"
                    else
                        printf "  %-${wa}s %-${w_host}s %-${w_user}s %-${w_dir}s %-${w_desc}s\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}" "${descriptions[$i]}"
                    fi
                fi
            done
        fi

        echo ""
        if [[ "$search_mode" == "true" ]]; then
            echo -e "${YELLOW}Type to filter | Backspace: delete | Esc: clear filter | Enter: select${NC}"
        else
            echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | /: Search | A: Auth | P: Parallel | L: List | H: Hard Reset | D: Default | Q: Exit${NC}"
        fi
    }

    redraw_menu() {
        tput civis
        tput cup 0 0
        tput ed
        draw_menu
    }

    # Helper: get the real index of the selected item in the filtered list
    get_selected_real_index() {
        local fi_count=${#filtered_indices[@]}
        if [[ $fi_count -eq 0 ]]; then
            echo -1
            return
        fi
        echo "${filtered_indices[$selected]}"
    }

    # Draw menu
    redraw_menu

    # Read keys
    while true; do
        local fi_count=${#filtered_indices[@]}
        # Read single key
        IFS= read -rsn1 key || continue

        if [[ "$search_mode" == "true" ]]; then
            # Search mode key handling
            if [[ "$key" == $'\x1b' ]]; then
                read -rsn2 -t 0.1 seq || true
                if [[ "$seq" == '[A' ]]; then
                    # Up arrow in search mode
                    if [[ $fi_count -gt 0 ]]; then
                        if [[ $selected -gt 0 ]]; then
                            selected=$((selected - 1))
                        else
                            selected=$((fi_count - 1))
                        fi
                    fi
                    draw_menu
                elif [[ "$seq" == '[B' ]]; then
                    # Down arrow in search mode
                    if [[ $fi_count -gt 0 ]]; then
                        if [[ $selected -lt $((fi_count - 1)) ]]; then
                            selected=$((selected + 1))
                        else
                            selected=0
                        fi
                    fi
                    draw_menu
                elif [[ -z "$seq" ]]; then
                    # Escape - exit search mode, clear filter
                    search_mode=false
                    filter_text=""
                    rebuild_filter
                    selected=0
                    draw_menu
                fi
            elif [[ "$key" == '' ]]; then
                # Enter - select current and exit search mode
                search_mode=false
                if [[ $fi_count -gt 0 ]]; then
                    local real_idx
                    real_idx=$(get_selected_real_index)
                    tput cnorm
                    connect "${aliases[$real_idx]}"
                    rebuild_filter
                    selected=0
                    redraw_menu
                fi
            elif [[ "$key" == $'\x7f' || "$key" == $'\x08' ]]; then
                # Backspace - remove last char
                if [[ ${#filter_text} -gt 0 ]]; then
                    filter_text="${filter_text%?}"
                    rebuild_filter
                    selected=0
                fi
                if [[ -z "$filter_text" ]]; then
                    search_mode=false
                fi
                draw_menu
            elif [[ "$key" =~ ^[[:print:]]$ ]]; then
                # Printable character - add to filter
                filter_text="${filter_text}${key}"
                rebuild_filter
                selected=0
                draw_menu
            fi
            continue
        fi

        # Normal mode key handling
        if [[ "$key" == $'\x1b' ]]; then
            # Escape sequence - read more
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow - wrap to bottom
                if [[ $fi_count -gt 0 ]]; then
                    if [[ $selected -gt 0 ]]; then
                        selected=$((selected - 1))
                    else
                        selected=$((fi_count - 1))
                    fi
                fi
                draw_menu
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow - wrap to top
                if [[ $fi_count -gt 0 ]]; then
                    if [[ $selected -lt $((fi_count - 1)) ]]; then
                        selected=$((selected + 1))
                    else
                        selected=0
                    fi
                fi
                draw_menu
            elif [[ -z "$seq" ]]; then
                # Just Escape
                tput cnorm
                exit 0
            fi
        elif [[ "$key" == '/' ]]; then
            # Enter search mode
            search_mode=true
            filter_text=""
            rebuild_filter
            selected=0
            draw_menu
        elif [[ "$key" == '' ]]; then
            # Enter key - connect with zellij session restore
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                tput cnorm
                connect "${aliases[$real_idx]}"
                filter_text=""
                rebuild_filter
                selected=0
                redraw_menu
            fi
        elif [[ "$key" == 'a' || "$key" == 'A' ]]; then
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                tput cnorm
                connect_auth "${aliases[$real_idx]}"
                filter_text=""
                rebuild_filter
                selected=0
                redraw_menu
            fi
        elif [[ "$key" == 'p' || "$key" == 'P' ]]; then
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                tput cnorm
                connect_parallel "${aliases[$real_idx]}"
                filter_text=""
                rebuild_filter
                selected=0
                redraw_menu
            fi
        elif [[ "$key" == 'h' || "$key" == 'H' ]]; then
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                tput cnorm
                connect_hard_reset "${aliases[$real_idx]}" --force
                filter_text=""
                rebuild_filter
                selected=0
                redraw_menu
            fi
        elif [[ "$key" == 'l' || "$key" == 'L' ]]; then
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                tput cnorm
                list_and_connect "${aliases[$real_idx]}"
                filter_text=""
                rebuild_filter
                selected=0
                redraw_menu
            fi
        elif [[ "$key" == 'd' || "$key" == 'D' ]]; then
            if [[ $fi_count -gt 0 ]]; then
                local real_idx
                real_idx=$(get_selected_real_index)
                set_default "${aliases[$real_idx]}"
                default_conn="${aliases[$real_idx]}"
                draw_menu
            fi
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q to quit
            tput cnorm
            exit 0
        fi
    done
}

# Set default connection
set_default() {
    local new_default="$1"

    # Check if connection exists
    if ! awk -F'|' -v key="$new_default" '$1 == key {found=1; exit} END {exit !found}' "$CONFIG_FILE"; then
        echo -e "${RED}Error: Connection '$new_default' not found${NC}"
        exit 1
    fi

    # Remove old default
    sed -i '/^default=/d' "$CONFIG_FILE"

    # Add new default
    echo "default=$new_default" >> "$CONFIG_FILE"

    echo -e "${GREEN}Default set to: $new_default${NC}"
}

# === Session Helper Functions ===

# Get all sessions for an alias (supports parallel sessions like alias, alias_2, alias_3)
# Runs locally - queries remote server via SSH
get_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local safe_alias
    safe_alias=$(regex_escape "$alias")
    # Build timeout command array
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    # Get sessions from remote, strip ANSI codes, filter by alias pattern
    _timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | \
        sed 's/\x1b\[[0-9;]*m//g' | \
        grep -E "^${safe_alias}(_[0-9]+)?(\s|$)" | \
        awk '{print $1}'
}

# Count sessions for an alias
count_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    get_sessions_for_alias "$alias" "${ssh_cmd[@]}" | wc -l
}

# Get next parallel session name
get_next_session_name() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")
    local count
    count=$(echo "$sessions" | grep -c . || echo "0")

    if [[ $count -eq 0 ]]; then
        echo "$alias"
    else
        # Find highest number suffix and increment
        local max=1
        while IFS= read -r s; do
            if [[ "$s" =~ _([0-9]+)$ ]]; then
                local n="${BASH_REMATCH[1]}"
                (( n >= max )) && max=$((n + 1))
            fi
        done <<< "$sessions"
        echo "${alias}_${max}"
    fi
}

# Check if a specific session is exited/dead
is_session_exited() {
    local session="$1"
    shift
    local ssh_cmd=("$@")
    local safe_session
    safe_session=$(regex_escape "$session")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    _timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | grep -Eq "^${safe_session}.*EXITED"
}

# Cleanup dead/exited sessions for an alias
cleanup_dead_sessions() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local safe_alias
    safe_alias=$(regex_escape "$alias")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local sessions
    sessions=$(timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g')

    while IFS= read -r line; do
        if [[ "$line" =~ ^(${safe_alias}(_[0-9]+)?).*EXITED ]]; then
            local dead_session="${BASH_REMATCH[1]}"
            _timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij delete-session ${dead_session} --force 2>/dev/null" 2>/dev/null || true
        fi
    done <<< "$sessions"
}

# Delete all sessions for an alias
delete_all_sessions_for_alias() {
    local alias="$1"
    shift
    local ssh_cmd=("$@")
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    while IFS= read -r session; do
        [[ -n "$session" ]] && "${ssh_cmd_timeout[@]}" "zellij delete-session ${session} --force 2>/dev/null" 2>/dev/null || true
    done <<< "$sessions"
}

# === End Session Helper Functions ===

# List sessions on server and connect to selected one
list_and_connect() {
    local alias="$1"
    local auth_mode="${2:-}"  # Optional: "auth" for port forwarding mode
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    if ! parse_connection "$alias"; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit_or_return 1 "$stay_interactive"
        return 1
    fi
    local host="$CONN_HOST" port="$CONN_PORT" user="$CONN_USER"
    local directory="$CONN_DIR" description="$CONN_DESC" key="$CONN_KEY"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        exit_or_return 1 "$stay_interactive"
        return 1
    fi

    # Build SSH command arrays (base and auth)
    build_ssh_cmd "$host" "$port" "$user" "$key"
    local ssh_cmd=("${SSH_CMD[@]}")
    build_ssh_cmd "$host" "$port" "$user" "$key" "auth"
    local ssh_cmd_auth=("${SSH_CMD[@]}")

    local cd_cmd
    cd_cmd=$(build_cd_cmd "$directory")

    echo -e "${GREEN}=== Sessions on $alias ($description) ===${NC}"
    echo -e "${YELLOW}Fetching sessions...${NC}"

    # Get sessions from server (strip ANSI color codes) - filter by alias pattern
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    if [[ -z "$sessions" ]]; then
        echo -e "${RED}No sessions found for '$alias'.${NC}"
        read -p "Create new session '$alias'? [Y/n/b=back] " confirm
        if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
            exit_or_return 0 "$stay_interactive"; return 0
        elif [[ "$confirm" == "b" || "$confirm" == "B" ]]; then
            exit_or_return 0 "$stay_interactive"; return 0
        fi
        local final_ssh=("${ssh_cmd[@]}")
        [[ "$auth_mode" == "auth" ]] && final_ssh=("${ssh_cmd_auth[@]}")
        set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
        "${final_ssh[@]}" -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${alias}"
        reset_terminal
        exit_or_return 0 "$stay_interactive"; return 0
    fi

    # Build session array from filtered sessions
    local session_array=()
    while IFS= read -r session; do
        [[ -n "$session" ]] && session_array+=("$session")
    done <<< "$sessions"

    # Add "New parallel session" option
    session_array+=("[NEW] Create parallel session")

    local count=${#session_array[@]}
    local selected=0

    # Hide cursor and setup cleanup
    cleanup() {
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Cache session status once (avoid SSH call per session per redraw)
    local ssh_cmd_timeout=("${ssh_cmd[0]}" "${SSH_QUERY_TIMEOUT_OPTS[@]}" "${ssh_cmd[@]:1}")
    local _cached_session_list=""
    refresh_session_cache() {
        _cached_session_list=$(timeout "$SSH_QUERY_MAX_SECS" "${ssh_cmd_timeout[@]}" "zellij list-sessions 2>/dev/null" 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' || echo "")
    }
    refresh_session_cache

    # Draw function
    draw_sessions() {
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== Sessions for $alias ($description) ===${NC}"
        if [[ "$auth_mode" == "auth" ]]; then
            echo -e "${YELLOW}[Auth Mode: Port 1455 forwarding enabled]${NC}"
        fi
        echo ""

        for i in "${!session_array[@]}"; do
            local session="${session_array[$i]}"
            local is_new=false
            local is_exited=false
            [[ "$session" == "[NEW]"* ]] && is_new=true
            # Check cached session list for exited status
            local safe_session
            safe_session=$(regex_escape "$session")
            echo "$_cached_session_list" | grep -Eq "^${safe_session}.*EXITED" && is_exited=true

            if [[ $i -eq $selected ]]; then
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}\e[7m> %s\e[27m${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}\e[7m> %s (EXITED)\e[27m${NC}\n" "$session"
                else
                    printf "${GREEN}\e[7m> %s\e[27m${NC}\n" "$session"
                fi
            else
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}  %s${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}  %s (EXITED)${NC}\n" "$session"
                else
                    printf "${GREEN}  %s${NC}\n" "$session"
                fi
            fi
        done

        echo ""
        echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | H: Hard Reset | Q: Back${NC}"
    }

    tput cup 0 0
    tput ed
    draw_sessions

    # Read keys
    while true; do
        IFS= read -rsn1 key || continue

        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow
                if [[ $selected -gt 0 ]]; then
                    selected=$((selected - 1))
                else
                    selected=$((count - 1))
                fi
                draw_sessions
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow
                if [[ $selected -lt $((count - 1)) ]]; then
                    selected=$((selected + 1))
                else
                    selected=0
                fi
                draw_sessions
            elif [[ -z "$seq" ]]; then
                # Escape - back
                tput cnorm
                exit_or_return 0 "$stay_interactive"; return 0
            fi
        elif [[ "$key" == '' ]]; then
            # Enter - connect to selected or create new parallel
            tput cnorm
            local selected_session="${session_array[$selected]}"

            if [[ "$selected_session" == "[NEW]"* ]]; then
                echo -e "${GREEN}Creating new parallel session...${NC}"
                connect_parallel "$alias" "$auth_mode"
                exit_or_return 0 "$stay_interactive"; return 0
            else
                local session_name="$selected_session"
                echo -e "${GREEN}Connecting to session '$session_name'...${NC}"
                local final_ssh=("${ssh_cmd[@]}")
                [[ "$auth_mode" == "auth" ]] && final_ssh=("${ssh_cmd_auth[@]}")
                set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
                "${final_ssh[@]}" -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach ${session_name}"
                reset_terminal
                exit_or_return 0 "$stay_interactive"; return 0
            fi
        elif [[ "$key" == 'h' || "$key" == 'H' ]]; then
            # H - hard reset selected session only
            local selected_session="${session_array[$selected]}"
            if [[ "$selected_session" == "[NEW]"* ]]; then
                # Can't reset [NEW] option, just create parallel
                tput cnorm
                echo -e "${GREEN}Creating new parallel session...${NC}"
                connect_parallel "$alias" "$auth_mode"
                exit_or_return 0 "$stay_interactive"; return 0
            else
                tput cnorm
                echo -e "${YELLOW}Hard reset session '$selected_session'...${NC}"
                connect_hard_reset "$alias" "$selected_session" --force
                exit_or_return 0 "$stay_interactive"; return 0
            fi
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q - back to main menu
            tput cnorm
            exit_or_return 0 "$stay_interactive"; return 0
        fi
    done
}

# Hard reset - delete session(s) and create fresh
# Args: alias [specific_session] [--force]
connect_hard_reset() {
    local alias="$1"
    local specific_session=""
    local force=false
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|--yes) force=true ;;
            *) specific_session="$1" ;;
        esac
        shift
    done
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    if ! parse_connection "$alias"; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit_or_return 1 "$stay_interactive"; return 1
    fi
    local host="$CONN_HOST" port="$CONN_PORT" user="$CONN_USER"
    local directory="$CONN_DIR" description="$CONN_DESC" key="$CONN_KEY"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        exit_or_return 1 "$stay_interactive"; return 1
    fi

    # Build SSH command array
    build_ssh_cmd "$host" "$port" "$user" "$key"
    local ssh_cmd=("${SSH_CMD[@]}")

    local cd_cmd
    cd_cmd=$(build_cd_cmd "$directory")

    # If specific session provided (from submenu H), reset only that one
    if [[ -n "$specific_session" ]]; then
        echo -e "${GREEN}Hard Reset: $specific_session${NC}"
        echo -e "${YELLOW}Deleting session '${specific_session}' and creating fresh...${NC}"
        echo ""
        local remote_cmd="zellij delete-session ${specific_session} --force 2>/dev/null; ${cd_cmd}zellij attach -c ${specific_session}"
        set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
        "${ssh_cmd[@]}" -t "$remote_cmd"
        reset_terminal
        exit_or_return 0 "$stay_interactive"; return 0
    fi

    # Confirm unless --force
    if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}This will delete ALL sessions for '$alias' and create a fresh one.${NC}"
        read -p "Continue? [y/N] " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${BLUE}Cancelled.${NC}"
            exit_or_return 0 "$stay_interactive"; return 0
        fi
    fi

    # Skip session query — just force-delete and create fresh
    # This ensures Hard Reset works even when the server is slow or sessions are stale
    echo -e "${GREEN}Hard Reset: $alias ($description)${NC}"
    echo -e "${YELLOW}Deleting session '${alias}' and creating fresh...${NC}"
    echo ""

    # Force-delete primary session and any parallel sessions, then create fresh
    local safe_alias_remote
    safe_alias_remote=$(regex_escape "$alias")
    local remote_cmd="for s in \$(zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -oE '^${safe_alias_remote}(_[0-9]+)?' || true); do zellij delete-session \"\$s\" --force 2>/dev/null; done; ${cd_cmd}zellij attach -c ${alias}"
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"
    "${ssh_cmd[@]}" -t "$remote_cmd"
    reset_terminal
    exit_or_return 0 "$stay_interactive"; return 0
}

# Connect to a connection (smart routing based on session count)
connect() {
    local alias="$1"
    local auth_mode="${2:-}"  # Optional: "auth" for port forwarding mode
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    if ! parse_connection "$alias"; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit_or_return 1 "$stay_interactive"; return 1
    fi
    local host="$CONN_HOST" port="$CONN_PORT" user="$CONN_USER"
    local directory="$CONN_DIR" description="$CONN_DESC" key="$CONN_KEY"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        exit_or_return 1 "$stay_interactive"; return 1
    fi

    # Build SSH command array
    build_ssh_cmd "$host" "$port" "$user" "$key"
    local ssh_cmd=("${SSH_CMD[@]}")

    local cd_cmd
    cd_cmd=$(build_cd_cmd "$directory")

    # Cleanup dead sessions first
    echo -e "${YELLOW}Checking sessions...${NC}"
    cleanup_dead_sessions "$alias" "${ssh_cmd[@]}"

    # Count remaining sessions
    local session_count
    session_count=$(count_sessions_for_alias "$alias" "${ssh_cmd[@]}")

    if [[ $session_count -gt 1 ]]; then
        # Multiple sessions exist -> go to session submenu
        echo -e "${BLUE}Found $session_count sessions for $alias${NC}"
        list_and_connect "$alias" "$auth_mode"
        return $?
    fi

    # Get existing session or use primary name
    local sessions
    sessions=$(get_sessions_for_alias "$alias" "${ssh_cmd[@]}")
    local session_name
    if [[ $session_count -eq 1 ]]; then
        session_name=$(echo "$sessions" | head -1)
    else
        session_name="$alias"
    fi

    # Build final SSH command array with auth port forwarding if needed
    local final_ssh_cmd=("${ssh_cmd[@]}")
    if [[ "$auth_mode" == "auth" ]]; then
        build_ssh_cmd "$host" "$port" "$user" "$key" "auth"
        final_ssh_cmd=("${SSH_CMD[@]}")
    fi

    # Build remote command
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Connecting to: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"
    if [[ "$auth_mode" == "auth" ]]; then
        echo -e "${YELLOW}Port Forward: localhost:1455 -> remote:1455${NC}"
    fi
    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi
    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Set terminal window title to user@host - description
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"

    # Execute SSH and reset terminal after disconnect
    run_ssh "$remote_cmd" "$user" "$host" "$port" "${final_ssh_cmd[@]}"
    reset_terminal
}

# Connect with port forwarding for authentication (port 1455)
# Delegates to connect() with auth mode flag
connect_auth() {
    local alias="$1"
    connect "$alias" "auth"
}

# Create a new parallel session (e.g., alias_2, alias_3, ...)
connect_parallel() {
    local alias="$1"
    local auth_mode="${2:-}"
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    if ! parse_connection "$alias"; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit_or_return 1 "$stay_interactive"; return 1
    fi
    local host="$CONN_HOST" port="$CONN_PORT" user="$CONN_USER"
    local directory="$CONN_DIR" description="$CONN_DESC" key="$CONN_KEY"

    # Validate port
    if ! validate_port "$port" "$alias"; then
        exit_or_return 1 "$stay_interactive"; return 1
    fi

    # Build SSH command array
    build_ssh_cmd "$host" "$port" "$user" "$key" "$auth_mode"
    local ssh_cmd=("${SSH_CMD[@]}")

    local cd_cmd
    cd_cmd=$(build_cd_cmd "$directory")

    # Get next available parallel session name
    echo -e "${YELLOW}Finding next available session name...${NC}"
    local session_name
    session_name=$(get_next_session_name "$alias" "${ssh_cmd[@]}")

    # Build remote command
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Creating parallel session: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"
    if [[ "$auth_mode" == "auth" ]]; then
        echo -e "${YELLOW}Port Forward: localhost:1455 -> remote:1455${NC}"
    fi
    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi
    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Set terminal window title to user@host - description
    set_terminal_title "$(build_connection_title "$user" "$host" "$description")"

    # Execute SSH
    run_ssh "$remote_cmd" "$user" "$host" "$port" "${ssh_cmd[@]}"
    reset_terminal
}

# Run SSH with detailed error handling
# Args: remote_cmd, user, host, port, ssh_cmd_elements...
run_ssh() {
    local remote_cmd="$1"
    local user="$2"
    local host="$3"
    local port="$4"
    shift 4
    local ssh_cmd=("$@")

    # Run SSH and capture exit code + stderr (using temp file for reliable capture)
    local stderr_file=$(mktemp)
    trap "rm -f '$stderr_file'" RETURN

    set +e
    "${ssh_cmd[@]}" -t "$remote_cmd" 2>"$stderr_file"
    local exit_code=$?
    set -e

    local ssh_stderr=$(cat "$stderr_file" 2>/dev/null || echo "")

    # Handle common SSH errors
    if [[ $exit_code -ne 0 ]]; then
        # Reset terminal first (fixes mouse tracking leaks from broken connections)
        reset_terminal

        # Check for broken pipe (mid-session disconnect) - exit cleanly
        if [[ "$ssh_stderr" == *"Broken pipe"* ]] || [[ "$ssh_stderr" == *"client_loop"* ]]; then
            echo ""
            echo -e "${YELLOW}Connection closed (broken pipe)${NC}"
            return 0
        fi

        echo ""
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${RED}SSH Connection Failed (Exit code: $exit_code)${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        case $exit_code in
            1)
                echo -e "${YELLOW}Generic error. Possible causes:${NC}"
                echo "  • Wrong hostname or IP address"
                echo "  • Network unreachable"
                echo "  • SSH key passphrase incorrect"
                ;;
            2)
                echo -e "${YELLOW}SSH client error. Possible causes:${NC}"
                echo "  • Invalid SSH options"
                echo "  • Configuration file syntax error"
                ;;
            255)
                echo -e "${YELLOW}Connection refused or failed. Possible causes:${NC}"
                echo ""
                echo -e "${BLUE}Server-side (sshd) issues:${NC}"
                echo "  • sshd not running: sudo systemctl start sshd"
                echo "  • sshd not enabled: sudo systemctl enable sshd"
                echo "  • Wrong port: check /etc/ssh/sshd_config 'Port' setting"
                echo "  • Firewall blocking: sudo ufw allow ${port}/tcp"
                echo ""
                echo -e "${BLUE}Authentication issues:${NC}"
                echo "  • User '${user}' doesn't exist on server"
                echo "  • SSH key not in ~/.ssh/authorized_keys"
                echo "  • PasswordAuthentication disabled in sshd_config"
                echo "  • PubkeyAuthentication disabled in sshd_config"
                echo ""
                echo -e "${BLUE}Port forwarding issues (if using -L):${NC}"
                echo "  • AllowTcpForwarding must be 'yes' in sshd_config"
                echo "  • GatewayPorts may need to be 'yes'"
                echo "  • Port 1455 already in use locally: lsof -i :1455"
                echo ""
                echo -e "${BLUE}To check sshd config on server:${NC}"
                echo "  sudo sshd -T | grep -E '(port|allowtcp|pubkey|password)'"
                ;;
            *)
                echo -e "${YELLOW}Unknown error. Check:${NC}"
                echo "  • Network connectivity: ping ${host}"
                echo "  • SSH service: ssh -v ${user}@${host}"
                ;;
        esac

        echo ""
        echo -e "${BLUE}Debug with: ssh -vvv -p ${port} ${user}@${host}${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        read -p "Press Enter to continue..."
    fi
}

# Test SSH connectivity for a connection
test_connection() {
    local alias="$1"

    if ! parse_connection "$alias"; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit 1
    fi
    local host="$CONN_HOST" port="$CONN_PORT" user="$CONN_USER" key="$CONN_KEY"

    if ! validate_port "$port" "$alias"; then
        exit 1
    fi

    echo -e "${YELLOW}Testing connection to $alias (${user}@${host}:${port})...${NC}"

    local ssh_test_cmd=(ssh -o ConnectTimeout=5 -o BatchMode=yes -o StrictHostKeyChecking=accept-new)
    [[ -n "$key" ]] && ssh_test_cmd+=(-i "$key")
    ssh_test_cmd+=(-p "$port" "${user}@${host}" "exit 0")

    local start_time=$SECONDS
    set +e
    "${ssh_test_cmd[@]}" 2>/dev/null
    local exit_code=$?
    set -e
    local elapsed=$(( SECONDS - start_time ))

    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}OK: $alias reachable (${elapsed}s)${NC}"
    else
        echo -e "${RED}FAIL: $alias unreachable (exit code $exit_code, ${elapsed}s)${NC}"
        exit 1
    fi
}

# Validate config file
validate_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${RED}Config file not found: $CONFIG_FILE${NC}"
        exit 1
    fi

    echo -e "${GREEN}Validating: $CONFIG_FILE${NC}"
    local errors=0
    local connections=0
    local line_num=0

    while IFS= read -r line; do
        line_num=$((line_num + 1))
        # Skip comments, empty lines, defaults, host aliases
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ "$line" =~ ^default= ]] && continue
        [[ "$line" =~ ^hostalias: ]] && continue

        connections=$((connections + 1))

        # Parse fields
        local alias host port user directory description key
        IFS='|' read -r alias host port user directory description key <<< "$line"

        # Validate required fields
        if [[ -z "$alias" ]]; then
            echo -e "${RED}  Line $line_num: missing alias${NC}"
            errors=$((errors + 1))
            continue
        fi
        if [[ -z "$host" ]]; then
            echo -e "${RED}  Line $line_num ($alias): missing host${NC}"
            errors=$((errors + 1))
        fi
        if ! validate_port "$port" "$alias" 2>/dev/null; then
            echo -e "${RED}  Line $line_num ($alias): invalid port '$port'${NC}"
            errors=$((errors + 1))
        fi
        if [[ -z "$user" ]]; then
            echo -e "${RED}  Line $line_num ($alias): missing user${NC}"
            errors=$((errors + 1))
        fi

        # Check SSH key file if specified
        if [[ -n "$key" ]]; then
            local expanded_key="${key/#\~/$HOME}"
            if [[ ! -f "$expanded_key" ]]; then
                echo -e "${YELLOW}  Line $line_num ($alias): SSH key not found: $key${NC}"
            fi
        fi
    done < "$CONFIG_FILE"

    echo ""
    echo -e "${BLUE}Connections: $connections${NC}"
    if [[ $errors -eq 0 ]]; then
        echo -e "${GREEN}No errors found.${NC}"
    else
        echo -e "${RED}Found $errors error(s).${NC}"
        exit 1
    fi
}

# Add a new connection via interactive wizard
add_connection() {
    echo -e "${GREEN}=== Add New Connection ===${NC}"
    echo ""

    local alias host port user directory description key

    read -p "Alias (unique name, e.g. myserver): " alias
    if [[ -z "$alias" ]] || [[ "$alias" == *"|"* ]]; then
        echo -e "${RED}Error: Alias cannot contain '|' or be empty${NC}"
        exit 1
    fi
    # Check for duplicate
    if awk -F'|' -v key="$alias" '$1 == key {found=1; exit} END {exit !found}' "$CONFIG_FILE" 2>/dev/null; then
        echo -e "${RED}Error: Connection '$alias' already exists.${NC}"
        exit 1
    fi

    read -p "Host (hostname or IP): " host
    if [[ -z "$host" ]]; then
        echo -e "${RED}Host is required.${NC}"
        exit 1
    fi

    read -p "Port [22]: " port
    port="${port:-22}"
    if ! validate_port "$port" "$alias"; then
        exit 1
    fi

    read -p "User: " user
    if [[ -z "$user" ]]; then
        echo -e "${RED}User is required.${NC}"
        exit 1
    fi

    read -p "Directory (optional, remote path after login): " directory
    read -p "Description (optional): " description
    read -p "SSH key path (optional, e.g. ~/.ssh/id_rsa): " key

    # Validate no fields contain the config delimiter
    if [[ "$host" == *"|"* ]] || [[ "$user" == *"|"* ]] || [[ "$description" == *"|"* ]] || [[ "$directory" == *"|"* ]] || [[ "$key" == *"|"* ]]; then
        echo -e "${RED}Error: Fields cannot contain '|' (config delimiter)${NC}"
        exit 1
    fi

    local line="${alias}|${host}|${port}|${user}|${directory}|${description}|${key}"
    echo "$line" >> "$CONFIG_FILE"
    echo -e "${GREEN}Connection '$alias' added.${NC}"
}

# Remove a connection by alias
remove_connection() {
    local alias="$1"

    if ! awk -F'|' -v key="$alias" '$1 == key {found=1; exit} END {exit !found}' "$CONFIG_FILE"; then
        echo -e "${RED}Error: Connection '$alias' not found.${NC}"
        exit 1
    fi

    read -p "Remove connection '$alias'? [y/N] " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${BLUE}Cancelled.${NC}"
        exit 0
    fi

    # Remove the line matching the alias (exact match on first field)
    awk -F'|' -v key="$alias" '$1 != key' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    echo -e "${GREEN}Connection '$alias' removed.${NC}"
}

# Output shell completions
generate_completions() {
    local shell="${1:-bash}"

    case "$shell" in
        bash)
            cat <<'COMPEOF'
# SM bash completions - source this or add to ~/.bashrc
_sm_completions() {
    local cur prev commands
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    commands="list set edit test validate doctor auth parallel reset sessions add remove completions"

    case "$prev" in
        sm)
            COMPREPLY=($(compgen -W "$commands --help --version --no-color" -- "$cur"))
            return
            ;;
        set|test|auth|parallel|reset|sessions|remove)
            local aliases
            aliases=$(awk -F'|' '!/^(#|$|default=|hostalias:)/ {print $1}' ~/.config/sm/connections.conf 2>/dev/null)
            COMPREPLY=($(compgen -W "$aliases" -- "$cur"))
            return
            ;;
        completions)
            COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
            return
            ;;
    esac
}
complete -F _sm_completions sm
COMPEOF
            ;;
        zsh)
            cat <<'COMPEOF'
# SM zsh completions - source this or add to ~/.zshrc
_sm() {
    local commands aliases
    commands=(list set edit test validate doctor auth parallel reset sessions add remove completions --help --version --no-color)
    aliases=(${(f)"$(awk -F'|' '!/^(#|$|default=|hostalias:)/ {print $1}' ~/.config/sm/connections.conf 2>/dev/null)"})

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        _describe 'alias' aliases
    elif (( CURRENT == 3 )); then
        case "$words[2]" in
            set|test|auth|parallel|reset|sessions|remove)
                _describe 'alias' aliases
                ;;
            completions)
                _describe 'shell' '(bash zsh)'
                ;;
        esac
    fi
}
compdef _sm sm
COMPEOF
            ;;
        *)
            echo -e "${RED}Unknown shell: $shell (use 'bash' or 'zsh')${NC}"
            exit 1
            ;;
    esac
}

# Main
main() {
    # Pre-parse global flags before init_config (--help, --version, --no-color)
    local args=()
    for arg in "$@"; do
        case "$arg" in
            --help|-h)
                show_help
                exit 0
                ;;
            --version|-v)
                echo "sm $SM_VERSION"
                exit 0
                ;;
            --no-color)
                RED='' GREEN='' YELLOW='' BLUE='' NC=''
                ;;
            *)
                args+=("$arg")
                ;;
        esac
    done
    set -- "${args[@]+"${args[@]}"}"

    # Commands that don't need config
    if [[ $# -ge 1 && "$1" == "completions" ]]; then
        generate_completions "${2:-bash}"
        exit 0
    fi

    init_config

    # Get script name (for smd, sml detection)
    local script_name=$(basename "$0")

    # Handle different invocations
    case "$script_name" in
        smd)
            # smd = connect to default (quick access)
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sml)
            # sml = list zellij sessions on default server
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                list_and_connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sm)
            # sm with arguments
            if [[ $# -eq 0 ]]; then
                # No args = interactive selection
                interactive_select
            elif [[ "$1" == "list" ]]; then
                list_connections
            elif [[ "$1" == "set" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm set <alias>${NC}"
                    exit 1
                fi
                set_default "$2"
            elif [[ "$1" == "edit" ]]; then
                "${EDITOR:-vi}" "$CONFIG_FILE"
            elif [[ "$1" == "test" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm test <alias>${NC}"
                    exit 1
                fi
                test_connection "$2"
            elif [[ "$1" == "validate" || "$1" == "doctor" ]]; then
                validate_config
            elif [[ "$1" == "auth" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm auth <alias>${NC}"
                    exit 1
                fi
                connect_auth "$2"
            elif [[ "$1" == "parallel" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm parallel <alias>${NC}"
                    exit 1
                fi
                connect_parallel "$2"
            elif [[ "$1" == "reset" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm reset <alias> [--force]${NC}"
                    exit 1
                fi
                local reset_alias="$2"
                shift 2
                connect_hard_reset "$reset_alias" "$@"
            elif [[ "$1" == "sessions" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm sessions <alias>${NC}"
                    exit 1
                fi
                list_and_connect "$2"
            elif [[ "$1" == "add" ]]; then
                add_connection
            elif [[ "$1" == "remove" || "$1" == "rm" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm remove <alias>${NC}"
                    exit 1
                fi
                remove_connection "$2"
            else
                # Direct connection by alias
                connect "$1"
            fi
            ;;
        *)
            echo -e "${RED}Unknown command: $script_name${NC}"
            exit 1
            ;;
    esac
}

main "$@"
