#!/usr/bin/env bash
# SM - SSH Manager
# Quick SSH connection manager with zellij session persistence
# Invoke as 'sml' for list mode

set -uo pipefail

CONFIG_DIR="${HOME}/.config/sm"
CONFIG_FILE="${CONFIG_DIR}/connections.conf"
INTERACTIVE_MODE=0

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Reset terminal to sane state (fixes mouse reporting leaks after SSH disconnect)
reset_terminal() {
    # Disable all mouse reporting modes
    printf '\e[?1000l\e[?1002l\e[?1003l\e[?1006l' 2>/dev/null
    # Show cursor
    tput cnorm 2>/dev/null
    # Reset terminal to sane state
    stty sane 2>/dev/null
}

# No mouse_mode fix needed - use Shift+RightClick for paste in terminal
ZELLIJ_MOUSE_FIX=''

# rmate reverse port forwarding (allows editing remote files with local editor)
# Usage on server: rmate filename.txt
RMATE_FORWARD='-R 52698:localhost:52698'

# Initialize config if not exists
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# SM - SSH Manager Configuration
# Format: alias|host|port|user|directory|description|[ssh_key]
#
# Example:
# sm231|contabo2.example.com|22|rob-ico|ico-n8n-prozesse2|N8N Server|
# sm232|contabo2.example.com|22|rob-ico|ico-cert|Cert Service|~/.ssh/special_key
#
# Host aliases (optional):
# hostalias:contabo2.example.com=contabo2
#
# Set default connection:
# default=sm231

EOF
        echo -e "${YELLOW}Config file created: $CONFIG_FILE${NC}"
        echo -e "${YELLOW}Please edit it to add your connections.${NC}"
        exit 0
    fi
}

# Get default connection
get_default() {
    grep "^default=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2 | tr -d ' ' || echo ""
}

# Get host alias for a hostname
get_host_alias() {
    local hostname="$1"
    local alias_line=$(grep "^hostalias:${hostname}=" "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$alias_line" ]]; then
        echo "${alias_line#*=}"
    else
        echo ""
    fi
}

# List all connections (non-interactive)
list_connections() {
    local default_conn=$(get_default)

    echo -e "${GREEN}=== SM - SSH Manager ===${NC}"
    printf "%-10s %-12s %-15s %-35s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY"
    echo "--------------------------------------------------------------------------------"

    while IFS='|' read -r alias host port user directory description key; do
        # Skip comments, empty lines, host aliases, default
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        local hostalias=$(get_host_alias "$host")

        # Highlight default (green row)
        if [[ "$alias" == "$default_conn" ]]; then
            printf "${GREEN}%-10s %-12s %-15s %-35s${NC}\n" "$alias" "$hostalias" "$user" "$directory"
        else
            printf "%-10s %-12s %-15s %-35s\n" "$alias" "$hostalias" "$user" "$directory"
        fi
    done < "$CONFIG_FILE"
}

# Interactive selection with arrow keys
interactive_select() {
    INTERACTIVE_MODE=1
    local default_conn=$(get_default)
    local aliases=()
    local hostaliases=()
    local users=()
    local directories=()

    # Build arrays
    while IFS='|' read -r alias host port user directory description key; do
        [[ "$alias" =~ ^#.*$ ]] && continue
        [[ -z "$alias" ]] && continue
        [[ "$alias" =~ ^default= ]] && continue
        [[ "$alias" =~ ^hostalias: ]] && continue

        aliases+=("$alias")
        hostaliases+=("$(get_host_alias "$host")")
        users+=("$user")
        directories+=("$directory")
    done < "$CONFIG_FILE"

    local count=${#aliases[@]}
    if [[ $count -eq 0 ]]; then
        echo -e "${RED}No connections configured${NC}"
        exit 1
    fi

    # Find initial selection (default or first)
    local selected=0
    for i in "${!aliases[@]}"; do
        if [[ "${aliases[$i]}" == "$default_conn" ]]; then
            selected=$i
            break
        fi
    done

    # Hide cursor and setup cleanup
    cleanup() {
        INTERACTIVE_MODE=0
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Draw function
    draw_menu() {
        # Move to top and clear
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== SM - SSH Manager ===${NC}"
        printf "%-10s %-12s %-15s %-35s\n" "ALIAS" "HOSTALIAS" "USER" "DIRECTORY"
        echo "--------------------------------------------------------------------------------"

        for i in "${!aliases[@]}"; do
            local is_default=false
            [[ "${aliases[$i]}" == "$default_conn" ]] && is_default=true

            if [[ $i -eq $selected ]]; then
                # Selected row - inverse video
                if [[ "$is_default" == "true" ]]; then
                    printf "${GREEN}\e[7m> %-8s %-12s %-15s %-35s\e[27m${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                else
                    printf "\e[7m> %-8s %-12s %-15s %-35s\e[27m\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                fi
            else
                if [[ "$is_default" == "true" ]]; then
                    printf "${GREEN}  %-8s %-12s %-15s %-35s${NC}\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                else
                    printf "  %-8s %-12s %-15s %-35s\n" "${aliases[$i]}" "${hostaliases[$i]}" "${users[$i]}" "${directories[$i]}"
                fi
            fi
        done

        echo ""
        echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | A: Auth | L: List | H: Hard Reset | D: Default | Q: Exit${NC}"
    }

    redraw_menu() {
        tput civis
        tput cup 0 0
        tput ed
        draw_menu
    }

    # Draw menu
    redraw_menu

    # Read keys
    while true; do
        # Read single key
        IFS= read -rsn1 key || continue

        if [[ "$key" == $'\x1b' ]]; then
            # Escape sequence - read more
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow - wrap to bottom
                if [[ $selected -gt 0 ]]; then
                    selected=$((selected - 1))
                else
                    selected=$((count - 1))
                fi
                draw_menu
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow - wrap to top
                if [[ $selected -lt $((count - 1)) ]]; then
                    selected=$((selected + 1))
                else
                    selected=0
                fi
                draw_menu
            elif [[ -z "$seq" ]]; then
                # Just Escape
                tput cnorm
                exit 0
            fi
        elif [[ "$key" == '' ]]; then
            # Enter key - connect with zellij session restore
            tput cnorm
            connect "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'a' || "$key" == 'A' ]]; then
            # A key - Auth mode with port forwarding (1455)
            tput cnorm
            connect_auth "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'h' || "$key" == 'H' ]]; then
            # H key - hard reset (always delete and create fresh, no questions)
            tput cnorm
            connect_hard_reset "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'l' || "$key" == 'L' ]]; then
            # L key - list sessions on server and connect
            tput cnorm
            list_and_connect "${aliases[$selected]}"
            redraw_menu
        elif [[ "$key" == 'd' || "$key" == 'D' ]]; then
            # D key - set default
            set_default "${aliases[$selected]}"
            default_conn="${aliases[$selected]}"
            draw_menu
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q to quit
            tput cnorm
            exit 0
        fi
    done
}

# Set default connection
set_default() {
    local new_default="$1"

    # Check if connection exists
    if ! grep -q "^${new_default}|" "$CONFIG_FILE"; then
        echo -e "${RED}Error: Connection '$new_default' not found${NC}"
        exit 1
    fi

    # Remove old default
    sed -i '/^default=/d' "$CONFIG_FILE"

    # Add new default
    echo "default=$new_default" >> "$CONFIG_FILE"

    echo -e "${GREEN}Default set to: $new_default${NC}"
}

# List sessions on server and connect to selected one
list_and_connect() {
    local alias="$1"
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    local line=$(grep "^${alias}|" "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Build SSH command
    local ssh_cmd="ssh"
    if [[ -n "$key" ]]; then
        ssh_cmd="$ssh_cmd -i $key"
    fi
    ssh_cmd="$ssh_cmd $RMATE_FORWARD -p $port ${user}@${host}"

    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd $directory 2>/dev/null; "

    echo -e "${GREEN}=== Sessions on $alias ($description) ===${NC}"
    echo -e "${YELLOW}Fetching sessions...${NC}"

    # Get sessions from server (strip ANSI color codes)
    local sessions=$($ssh_cmd "zellij list-sessions 2>/dev/null" | sed 's/\x1b\[[0-9;]*m//g' | grep -v "^$")

    if [[ -z "$sessions" ]]; then
        echo -e "${RED}No sessions found on server.${NC}"
        read -p "Create new session '$alias'? [Y/n/b=back] " confirm
        if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        elif [[ "$confirm" == "b" || "$confirm" == "B" ]]; then
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        fi
        $ssh_cmd -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${alias}"
        reset_terminal
        if [[ $stay_interactive -eq 1 ]]; then
            return 0
        else
            exit 0
        fi
    fi

    # Build session array
    local session_array=()
    while IFS= read -r session; do
        session_array+=("$session")
    done <<< "$sessions"

    # Add "New session" option
    session_array+=("[NEW] Create session '$alias'")

    local count=${#session_array[@]}
    local selected=0

    # Hide cursor and setup cleanup
    cleanup() {
        reset_terminal
    }
    tput civis
    trap cleanup EXIT INT TERM HUP

    # Draw function
    draw_sessions() {
        tput cup 0 0
        tput ed

        echo -e "${GREEN}=== Sessions on $alias ($description) ===${NC}"
        echo ""

        for i in "${!session_array[@]}"; do
            local session="${session_array[$i]}"
            local is_new=false
            local is_exited=false
            [[ "$session" == "[NEW]"* ]] && is_new=true
            [[ "$session" == *"(EXITED)"* ]] && is_exited=true

            if [[ $i -eq $selected ]]; then
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}\e[7m> %s\e[27m${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}\e[7m> %s\e[27m${NC}\n" "$session"
                else
                    printf "${GREEN}\e[7m> %s\e[27m${NC}\n" "$session"
                fi
            else
                if [[ "$is_new" == "true" ]]; then
                    printf "${BLUE}  %s${NC}\n" "$session"
                elif [[ "$is_exited" == "true" ]]; then
                    printf "${RED}  %s${NC}\n" "$session"
                else
                    printf "${GREEN}  %s${NC}\n" "$session"
                fi
            fi
        done

        echo ""
        echo -e "${YELLOW}↑↓ Navigate | Enter: Connect | Esc/Q: Cancel${NC}"
    }

    tput cup 0 0
    tput ed
    draw_sessions

    # Read keys
    while true; do
        IFS= read -rsn1 key || continue

        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 seq || true
            if [[ "$seq" == '[A' ]]; then
                # Up arrow
                if [[ $selected -gt 0 ]]; then
                    selected=$((selected - 1))
                else
                    selected=$((count - 1))
                fi
                draw_sessions
            elif [[ "$seq" == '[B' ]]; then
                # Down arrow
                if [[ $selected -lt $((count - 1)) ]]; then
                    selected=$((selected + 1))
                else
                    selected=0
                fi
                draw_sessions
            elif [[ -z "$seq" ]]; then
                # Escape - back
                tput cnorm
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            fi
        elif [[ "$key" == '' ]]; then
            # Enter - connect
            tput cnorm
            local selected_session="${session_array[$selected]}"

            if [[ "$selected_session" == "[NEW]"* ]]; then
                echo -e "${GREEN}Creating fresh session '$alias'...${NC}"
                connect_hard_reset "$alias"
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            else
                local session_name=$(echo "$selected_session" | awk '{print $1}')
                echo -e "${GREEN}Connecting to session '$session_name'...${NC}"
                $ssh_cmd -t "${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach ${session_name}"
                reset_terminal
                if [[ $stay_interactive -eq 1 ]]; then
                    return 0
                else
                    exit 0
                fi
            fi
        elif [[ "$key" == 'q' || "$key" == 'Q' ]]; then
            # Q - back to main menu
            tput cnorm
            if [[ $stay_interactive -eq 1 ]]; then
                return 0
            else
                exit 0
            fi
        fi
    done
}

# Hard reset - always delete and create fresh session (no questions asked)
connect_hard_reset() {
    local alias="$1"
    local stay_interactive=0
    [[ "${INTERACTIVE_MODE:-0}" -eq 1 ]] && stay_interactive=1

    # Parse connection
    local line=$(grep "^${alias}|" "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        if [[ $stay_interactive -eq 1 ]]; then
            return 1
        else
            exit 1
        fi
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Build SSH command
    local ssh_cmd="ssh"
    if [[ -n "$key" ]]; then
        ssh_cmd="$ssh_cmd -i $key"
    fi
    ssh_cmd="$ssh_cmd $RMATE_FORWARD -p $port ${user}@${host}"

    local session_name="${alias}"
    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd $directory 2>/dev/null; "

    echo -e "${GREEN}Hard Reset: $alias ($description)${NC}"
    echo -e "${YELLOW}Deleting session '${session_name}' and creating fresh...${NC}"
    echo ""

    # Delete session with force (ignore errors) and create fresh
    local remote_cmd="zellij delete-session ${session_name} --force 2>/dev/null; ${cd_cmd}zellij attach -c ${session_name}"
    $ssh_cmd -t "$remote_cmd"
    reset_terminal
    if [[ $stay_interactive -eq 1 ]]; then
        return 0
    else
        exit 0
    fi
}

# Connect to a connection
connect() {
    local alias="$1"

    # Parse connection
    local line=$(grep "^${alias}|" "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit 1
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Build SSH command
    local ssh_cmd="ssh"

    if [[ -n "$key" ]]; then
        ssh_cmd="$ssh_cmd -i $key"
    fi

    ssh_cmd="$ssh_cmd $RMATE_FORWARD -p $port ${user}@${host}"

    # Build remote command - use zellij for session persistence
    local session_name="${alias}"
    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd $directory 2>/dev/null; "

    # Attach or create session (try attach first, create if not exists)
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Connecting to: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"

    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi

    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Execute SSH and reset terminal after disconnect
    run_ssh "$ssh_cmd" "$remote_cmd" "$user" "$host" "$port"
    reset_terminal
}

# Connect with port forwarding for authentication (port 1455)
connect_auth() {
    local alias="$1"

    # Parse connection
    local line=$(grep "^${alias}|" "$CONFIG_FILE" 2>/dev/null || echo "")

    if [[ -z "$line" ]]; then
        echo -e "${RED}Error: Connection '$alias' not found${NC}"
        exit 1
    fi

    IFS='|' read -r _ host port user directory description key <<< "$line"

    # Build SSH command with port forwarding
    local ssh_cmd="ssh"

    if [[ -n "$key" ]]; then
        ssh_cmd="$ssh_cmd -i $key"
    fi

    # Add port forwarding for authentication
    ssh_cmd="$ssh_cmd -L 1455:localhost:1455"
    ssh_cmd="$ssh_cmd $RMATE_FORWARD -p $port ${user}@${host}"

    # Build remote command - use zellij for session persistence
    local session_name="${alias}"
    local cd_cmd=""
    [[ -n "$directory" ]] && cd_cmd="cd $directory 2>/dev/null; "

    # Attach or create session
    local remote_cmd="${ZELLIJ_MOUSE_FIX}${cd_cmd}zellij attach -c ${session_name}"

    echo -e "${GREEN}Connecting to: $alias ($description)${NC}"
    echo -e "${BLUE}Host: ${user}@${host}:${port}${NC}"
    echo -e "${YELLOW}Port Forward: localhost:1455 -> remote:1455${NC}"

    if [[ -n "$directory" ]]; then
        echo -e "${BLUE}Directory: $directory${NC}"
    fi

    echo -e "${BLUE}Session: zellij ${session_name}${NC}"
    echo ""

    # Execute SSH with port forwarding
    run_ssh "$ssh_cmd" "$remote_cmd" "$user" "$host" "$port"
    reset_terminal
}

# Run SSH with detailed error handling
# Args: ssh_cmd, remote_cmd, user, host, port
run_ssh() {
    local ssh_cmd="$1"
    local remote_cmd="$2"
    local user="$3"
    local host="$4"
    local port="$5"

    # Run SSH and capture exit code
    set +e
    $ssh_cmd -t "$remote_cmd"
    local exit_code=$?
    set -e

    # Handle common SSH errors
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${RED}SSH Connection Failed (Exit code: $exit_code)${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        case $exit_code in
            1)
                echo -e "${YELLOW}Generic error. Possible causes:${NC}"
                echo "  • Wrong hostname or IP address"
                echo "  • Network unreachable"
                echo "  • SSH key passphrase incorrect"
                ;;
            2)
                echo -e "${YELLOW}SSH client error. Possible causes:${NC}"
                echo "  • Invalid SSH options"
                echo "  • Configuration file syntax error"
                ;;
            255)
                echo -e "${YELLOW}Connection refused or failed. Possible causes:${NC}"
                echo ""
                echo -e "${BLUE}Server-side (sshd) issues:${NC}"
                echo "  • sshd not running: sudo systemctl start sshd"
                echo "  • sshd not enabled: sudo systemctl enable sshd"
                echo "  • Wrong port: check /etc/ssh/sshd_config 'Port' setting"
                echo "  • Firewall blocking: sudo ufw allow ${port}/tcp"
                echo ""
                echo -e "${BLUE}Authentication issues:${NC}"
                echo "  • User '${user}' doesn't exist on server"
                echo "  • SSH key not in ~/.ssh/authorized_keys"
                echo "  • PasswordAuthentication disabled in sshd_config"
                echo "  • PubkeyAuthentication disabled in sshd_config"
                echo ""
                echo -e "${BLUE}Port forwarding issues (if using -L):${NC}"
                echo "  • AllowTcpForwarding must be 'yes' in sshd_config"
                echo "  • GatewayPorts may need to be 'yes'"
                echo "  • Port 1455 already in use locally: lsof -i :1455"
                echo ""
                echo -e "${BLUE}To check sshd config on server:${NC}"
                echo "  sudo sshd -T | grep -E '(port|allowtcp|pubkey|password)'"
                ;;
            *)
                echo -e "${YELLOW}Unknown error. Check:${NC}"
                echo "  • Network connectivity: ping ${host}"
                echo "  • SSH service: ssh -v ${user}@${host}"
                ;;
        esac

        echo ""
        echo -e "${BLUE}Debug with: ssh -vvv -p ${port} ${user}@${host}${NC}"
        echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"

        read -p "Press Enter to continue..."
    fi
}

# Main
main() {
    init_config

    # Get script name (for smd, sml detection)
    local script_name=$(basename "$0")

    # Handle different invocations
    case "$script_name" in
        smd)
            # smd = connect to default (quick access)
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sml)
            # sml = list zellij sessions on default server
            local default_conn=$(get_default)
            if [[ -n "$default_conn" ]]; then
                list_and_connect "$default_conn"
            else
                echo -e "${RED}No default connection set. Use 'sm set <alias>' to set one.${NC}"
                exit 1
            fi
            ;;
        sm)
            # sm with arguments
            if [[ $# -eq 0 ]]; then
                # No args = interactive selection
                interactive_select
            elif [[ "$1" == "list" ]]; then
                list_connections
            elif [[ "$1" == "set" ]]; then
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Usage: sm set <alias>${NC}"
                    exit 1
                fi
                set_default "$2"
            else
                # Direct connection by alias
                connect "$1"
            fi
            ;;
        *)
            echo -e "${RED}Unknown command: $script_name${NC}"
            exit 1
            ;;
    esac
}

main "$@"
